조 이름 : 16조
 
#역할
조원 :  통계학과 20212086 소연우
   역할 : ms azure과 putty를 이용한 외부서버 연결
 
         통계학과 20212196 이혜슬
   역할 :  로그 파일 기록 코드 구현, 랜덤으로 포트 추출하려 시도 
 
         수학과 20202279 박송원     	
   역할 : 클라이언트, 서버 코드 내 랜덤문제, system clock 구현
 
#프로그램 구성요소 :
1)     서버
클라이언트들에게 랜덤 사칙연산문제를 제출한다. System clock을 사용하여 문제 출제 시간, 답변 받은 시간 및 전체 풀이 시간을 계산하며 클라이언트에게서 5초 이내에 문제의 답을 받는다. 10분동안 계속해서 문제출제를 계속하며 10분이 지나면 연산결과의 누적 합을 제시하며 서버를 종료한다. 모든 이벤트를 로그파일에 저장하고, 동시에 접속한 4명의 클라이언트에 대해서 별도의 로그 파일을 만든다.
우선 랜덤 사칙연산 문제 생성하는 함수 make_question() 으로 정의한다. 
    >> 1 - 100까지 정수 중 랜덤한 숫자 num1, num2, num3 뽑는다.
    >> 연산자 ['+', '-', '*', '/'] 중 랜덤으로 oper1, oper2를 뽑는다.
    >> 이들을 조합해 만든 que 문자열을 파이썬 표현식으로 평가후 그 결과를 answer에 저장. 즉, 사칙 연산 문제의 답을 계산하여 저장 후 소수점을 버린 정수로 변환하여 res 저장한다.

handle 메서드에 클라이언트와의 상호작용 및 문제, 답변 처리, 시간 추적, 로깅 등 주요 서버 동작들을 입력한다.
    >> system clock의 현재 시간을 가져와 출력. 이는 클라이언트에게 제공되며 로깅에도 사용된다. 600초 이상 지났다면 서버를 종료하며 이를 클라이언트에 알리고 로깅한다.
    >> 연산 결과의 누적합을 출력하고 로그파일에 기록한다. 그 후 서버 소켓을 닫아서 새로운 클라이언트의 연결을 수락하지 않도록 하고 서버의 동작을 중지 및 루프도 종료한다.
     >> 이전 문제(오답)이 존재하는 경우 클라이언트에게 이전 오답 문제를 전송하고, 해당           문제를 로그에 남긴다. ‘이전문제’ 가 없는 경우 이 부분은 그냥 넘어가고 새 문제를 출제한다.  0 ~ 5초의 랜덤한 대기시간 만큼 클라이언트를 대기시킨다. 문제를 바로 출제하지 않고 클라이언트가 문제를 받는 시간 간격을 조절하고, 서버에 일정한 부하를 준다. make_question 함수를 사용하여 랜덤 사칙연산 문제를 생성하고, 이를 클라이언트에게 전송하며 로깅한다.
    >> 클라이언트에게 받은 작성한 답변과 경과시간 데이터를 디코딩하여 문자열 형태로 data 변수에 저장한다. 답변과 시간 데이터를 분리하고 경과 시간을 부동 소수점 숫자로 변환하여 저장하였다.
    >> 클라이언트가 입력한 값을 정수로 변환하여 저장하는데 클라이언트가 제출한 답변이 숫자가 아닌경우 입력값이 바르지 않음을 출력하고, 로그에 저장한다.
    >> 클라이언트가 제출한 답이 정답인지, 5초안에 답을 제출 했는지 확인 후 맞다면 정답을 출력하고 연산 누적 결과값을 저장하여 로깅한다 입력 했던 오답에 대한 변수를 초기화하여 다음 문제를 준비한다
    >> 답이 오답이라면 self.wrong_que, self.wrong_res 변수를 현재 que와 res으로 설정하여 클라이언트가 다시 동일한 문제를 제출제 할 수 있도록 한다. 답변의 경과시간이 5초가 지났다면 클라이언트에게 이를 알리고, 오답인 경우와 동일하게 처리하여 문제를 한번 더 풀 수 있도록 한다.

      
2)     클라이언트
서버로부터 랜덤 사칙연산 문제를 받아 풀이한다. 서버의 System clock을 이용하여 전체 풀이시간, 문제를 받은시간, 답변 제출 시간을 계산하며 5초이내에 답을 제출한다. 서버로부터 연산 결과에 대한 답을 듣고, 10분동안 문제풀이가 끝나면 연산 누적 합을 듣고 문제풀이를 종료한다. 각 4명의 클라이언트는 각자의 로그파일을 유지하며 모든 이벤트를 기록한다.
>> 서버로 부터 문제를 받은 후 사용자에게 답을 입력받고, 정답과 걸린 시간을 기록한다.
>> 소켓을 생성하고 바인딩한다. 클라이언트 소켓을 생성하고 로컬 호스트의 각 클라이언트 포트에 바인딩한다. 이는 클라이언트가 서버에 연결하기 위한 소켓을 설정한다.
>> 클라이언트 소켓을 with 문으로 감싸서 클라이언트 소켓이 블록을 빠져나올 때 자동으로 정리될 수 있도록한다. 클라이언트는 서버에 연결하고, 서버로부터 접속 완료 메시지를 받아 출력하고 로그에 기록한다.

3)     로그 파일
Python의 ‘logging’ 모듈을 사용하여 로그 파일을 만들고 관리한다. 모든 서버 및 4개의 클라이언트에 대해 각각의 로그 파일을 유치하며 출제된 문제 및 출제된 시간, 받은 답변 및 시간, 발생한 오류에 대한 정보 등 모든 이벤트들을 파일에 저장한다.
log_file_path = 'testlog/Tclient.txt'
    >> 로그 파일의 경로 및 파일 이름 설정
 log_directory = os.path.dirname(log_file_path)
    os.makedirs(log_directory, exist_ok=True)
	>>로그 파일의 디렉터리 경로 추출하고 로그 디렉터리 생성하는데, 로그 파일이 이미 존재하는 경우엔 생성하지 않고 무시하도록 하였다.
 
logging.basicConfig(
    filename=log_file_path,
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s]: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',       
    encoding='utf-8'
       >>로그 파일명,  로깅 레벨, 시간 – 메시지 레벨 – 로그 내용의 형식, 날짜 시간 입력형식을 지정한다.
2023-10-10 15:11:48 [INFO]: 클라이언트 접속 완료.
2023-10-10 15:11:48 [INFO]: 질문받음, 이전문제 : 38 - 94 / 84
2023-10-10 15:12:10 [INFO]: 사칙연산에 대한 정답 입력 : 7
2023-10-10 17:10:08 [ERROR]: 오류발생: [WinError 10054] 현재 연결은 원격 호스트에 의해 강제로 끊겼습니다
 


 이는 클라이언트 로그 파일의 일부이며 지정해둔 대로 파일이 기록 되고 있음을 볼 수 있다.
또한 try - except 문을 사용하여 예외 처리를 수행 하도록 했다. 이는 프로그램 실행하는 모든 예외를 변수 e에 저장하여 에러사항에 대한 정보를 로그 파일에 저장한다. 
try:
except Exception as e:
    logging.error(f'오류발생: {e}')



3) system clock
>> ‘__init__’ 메서드에서 클래스를 시간을 0으로 초기화한다. running 플래그를 설정하여 시계가 작동중인지 나타내고, 스레드락 및 백 그라운드에서 시간을 업데이트 한다.
>>update 메서드는 백그라운드 스레드로, self.running이 True일때 시스템 시간을 1초마다 업데이트한다. 스레드락을 사용하여 여러 스레드가 충돌하는 것을 방지한다.
>> get 메서드에서는 현재 시스템 시간을 반환한다.
>> 600초 경과 후 서버가 ‘종료’메시지를 보내 클라이언트가 메시지를 받고 소켓 연결을 종료한 후 서버에서 연결을 종료하고 thread_list에서 연결되어있던 클라이언트를 삭제하려고 하였다. 그런데 구현하는 과정에서 close로 클라이언트들의 연결을 종료를 시킨 후 10038에러가 떴고, 그 부분을 해결하지 못했다.

 외부서버에서의 구현
 
#소스코드 컴파일방법 : putty에서 파이썬 파일을 불러와 실행시켰다.
 
 
#프로그램 실행환경 및 실행방법 :
Python 프로그램 사용하여 서버, 클라이언트 코드를 작성한다.
과제 전제조건인 외부서버를 사용한 서버 구현을 위해 외부서버인 ms azure에서 linux ubuntu 가상머신을 생성한다.
생성한 가상머신의 공용IP주소로 putty를 연결한다.
가상머신 생성 과정에서 설정한 사용자명과 암호가 맞다면 시스템에 접속이 가능하다.
putty에서 서버, 클라이언트 파일을 명령어를 사용해 저장할 디렉토리를 생성
명령어 예시)
mkdir (생성할 디렉토리 이름)
윈도우에서 작성한 파이썬 파일을 가상머신으로 전송해야 하므로 윈도우 cmd창에서 putty로 scp명령어를 사용해 위 과정에서 생성한 디렉토리로 파일을 전송한다.
명령어 예시)
<윈도우 cmd>
scp (파이썬 파일 경로) (가상머신 사용자명)@(가상머신 공용IP):(보내고자 하는 디렉토리 절대경로)
<putty>
ls      : 존재하는 디렉토리 보여줌
cd  (디렉토리 이름)      : 해당 디렉토리로 이동(디렉토리 이름에 보내고자 하는 디렉토리 이름 적기)
-> 이렇게 파일을 보낸 디렉토리로 이동하여 다시 ls 명령어로 확인해보면 디렉토리 안에 보낸 파일이 존재한다는 것을 확인할 수 있다.
전송이 되면 ms azure와 연결된 putty에서 서버파일을 실행한다. 
명령어 예시)
python3 server.py
-> 서버 코드에 작성해놓은 ‘서버가 시작됨’ 이 출력되므로 실행이 되고있음을 확인 가능하다.
클라이언트 파일 실행을 위해 위 1개의 과정을 반복한다.
그 결과를 다시 윈도우 cmd로 옮겨 저장한다.이 과정은 아직까지 해보지 않음..
위 과정에서 저장된 것이 과제파일이 된다.

 
#Error or Additional handling :
랜덤 포트 실패
처음에 4명의 사용자가 동시에 접속하여, 각각 다른 포트를 이용해 각자 서버를 돌릴 수 있어야 한다라고 했을떄 4명에게 각자의 포트를 지정하는 것이 아닌, 서버 내에서 포트 번호를 랜덤으로 추출하고, 이를 클라이언트 스크립트로 보내 랜덤으로 추출된 해당 포트를 통해 통신 시키려고 했으나 계속된 에러로 각각 4개의 클라이언트 스크립트를 만들어 각자의 포트를 지정해두게 되었다.
아래는 랜덤으로 포트를 지정하려고 작성하였던 서버 스크립트이다.
class ServerWithRandomPort:
    def __init__(self):
        self.server_socket = None
        self.port = None   #여기 랜덤추출된 포트번호 저장
    def run(self):
        self.port = self.get_random_port() 
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server_socket.bind(('localhost', self.port))  #랜덤 포트에 바인딩
        self.server_socket.listen()
        print(f"서버가 시작됨. 포트 번호: {self.port}")
        while True:
            conn, addr = self.server_socket.accept()
            print(f'클라이언트 접속 : {addr}.')
            conn.sendall(f'포트번호 : {self.port}'.encode('utf-8')) #클라이언트에게 포트번호전송
            threading.Thread(target=self.handle_client, args=(conn,)).start() #클라이언트 처리 스레드시작
    def handle_client(self, conn): #클라이언트 처리 로직 추가
        pass            
    def get_random_port(self):
        return random.randint(1024, 65535) #랜덤포트 범위
    

> 아래는 클라이언트 스크립트의 랜덤포트 코드이다
class Client:
     def __init__(self):
        self.server_address = ('localhost', 0)  # 0으로 설정하면 OS에게 랜덤 포트 할당 요청
        self.server_port = None
        server_port_str = None
     def run(self):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect(('localhost', 0))
            server_port_str = s.recv(1024).decode('utf-8')  # 서버에서 문자열로 저장
            self.server_port = int(server_port_str)  #문자열을 정수로 변환
            print(f"서버의 포트 번호: {self.server_port}")
if __name__ == "__main__":
    client = Client()
    client.run()

외부서버 연결

600초
 
#Additional Comments :
